#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "$0")"

CLR_RESET=""
CLR_RED=""
CLR_GREEN=""
CLR_YELLOW=""
CLR_BLUE=""
CLR_DIM=""

if [[ -t 1 ]]; then
  CLR_RESET="\033[0m"
  CLR_RED="\033[31m"
  CLR_GREEN="\033[32m"
  CLR_YELLOW="\033[33m"
  CLR_BLUE="\033[34m"
  CLR_DIM="\033[2m"
fi

# TUI Theme - 256-color with 16-color fallback
TUI_BOLD=""
TUI_DIM=""
TUI_ITALIC=""
TUI_FG_TITLE=""
TUI_FG_SUBTITLE=""
TUI_FG_ACCENT=""
TUI_FG_MENU=""
TUI_FG_MENU_DIM=""
TUI_FG_SEPARATOR=""
TUI_FG_SHORTCUT=""
TUI_FG_STATUS=""
TUI_FG_BRANDING=""
TUI_FG_SELECTED=""
TUI_BG_TITLEBAR=""
TUI_BG_STATUSBAR=""
TUI_BG_SELECTED=""
TUI_BG_CONFIRM_YES=""
TUI_BG_CONFIRM_NO=""
TUI_FG_LOG_ERROR=""
TUI_FG_LOG_WARN=""
TUI_FG_LOG_INFO=""

if [[ -t 1 ]]; then
  TUI_BOLD="\033[1m"
  TUI_DIM="\033[2m"
  TUI_ITALIC="\033[3m"
  if [[ "${TERM:-}" == *256color* || "${COLORTERM:-}" == "truecolor" || "${COLORTERM:-}" == "24bit" ]]; then
    TUI_FG_TITLE="\033[38;5;15m"
    TUI_FG_SUBTITLE="\033[38;5;245m"
    TUI_FG_ACCENT="\033[38;5;75m"
    TUI_FG_MENU="\033[38;5;252m"
    TUI_FG_MENU_DIM="\033[38;5;243m"
    TUI_FG_SEPARATOR="\033[38;5;240m"
    TUI_FG_SHORTCUT="\033[38;5;75m"
    TUI_FG_STATUS="\033[38;5;250m"
    TUI_FG_BRANDING="\033[38;5;75m"
    TUI_FG_SELECTED="\033[38;5;15m"
    TUI_BG_TITLEBAR="\033[48;5;236m"
    TUI_BG_STATUSBAR="\033[48;5;236m"
    TUI_BG_SELECTED="\033[48;5;25m"
    TUI_BG_CONFIRM_YES="\033[48;5;28m"
    TUI_BG_CONFIRM_NO="\033[48;5;124m"
    TUI_FG_LOG_ERROR="\033[38;5;203m"
    TUI_FG_LOG_WARN="\033[38;5;221m"
    TUI_FG_LOG_INFO="\033[38;5;250m"
  else
    TUI_FG_TITLE="\033[1;37m"
    TUI_FG_SUBTITLE="\033[37m"
    TUI_FG_ACCENT="\033[1;34m"
    TUI_FG_MENU="\033[37m"
    TUI_FG_MENU_DIM="\033[2;37m"
    TUI_FG_SEPARATOR="\033[2;37m"
    TUI_FG_SHORTCUT="\033[1;34m"
    TUI_FG_STATUS="\033[37m"
    TUI_FG_BRANDING="\033[1;34m"
    TUI_FG_SELECTED="\033[1;37m"
    TUI_BG_TITLEBAR="\033[40m"
    TUI_BG_STATUSBAR="\033[40m"
    TUI_BG_SELECTED="\033[44m"
    TUI_BG_CONFIRM_YES="\033[42m"
    TUI_BG_CONFIRM_NO="\033[41m"
    TUI_FG_LOG_ERROR="\033[31m"
    TUI_FG_LOG_WARN="\033[33m"
    TUI_FG_LOG_INFO="\033[37m"
  fi
fi

# Box-drawing characters
BOX_H="─"
BOX_V="│"
BOX_TL="┌"
BOX_TR="┐"
BOX_BL="└"
BOX_BR="┘"
BOX_LT="├"
BOX_RT="┤"
BOX_TT="┬"
BOX_BT="┴"
BOX_CROSS="┼"

# Menu icons
ICO_SELECTED="▸ "
ICO_DOCKER="◆"
ICO_TOR="◈"
ICO_STOP="■"
ICO_RESTART="↻"
ICO_LOGS="☰"
ICO_STATUS="●"
ICO_JSON="{}"
ICO_ENV="≡"
ICO_ONION="◎"
ICO_IMPORT="↓"
ICO_UPGRADE="↑"
ICO_HELP="?"
ICO_QUIT="×"
ICO_BACK="←"
ICO_ADD="+"
ICO_CLEAR="∅"
ICO_EDIT="✎"
ICO_REMOVE="−"

# Spinner frames (Braille dots)
SPINNER_FRAMES=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

MODE="auto"
IMPORT_MODE="auto"
SKIP_IMPORT_PROMPT=0
TAIL_COUNT=100
LOG_SERVICE=""
FOLLOW_LOGS=1
BUILD_IMAGES=1
COMMAND=""
JSON_TOOL=""
VALIDATION_ERROR=""
VALIDATION_VALUE=""
RUN_OUTPUT=""
RUN_STATUS=0
TUI_ACTIVE=0
TUI_STTY_ORIG=""
TUI_COLS=0
TUI_LINES=0
LEFT_W=0
RIGHT_W=0
LEFT_X=1
RIGHT_X=0
LEFT_CONTENT_W=0
RIGHT_CONTENT_W=0
LEFT_CONTENT_ROW=2
RIGHT_CONTENT_ROW=2
LEFT_CONTENT_HEIGHT=0
RIGHT_CONTENT_HEIGHT=0
TUI_VIEW="main"
TUI_SEL=0
TUI_OFFSET=0
TUI_NEED_FRAME=1
TUI_NEED_LEFT=1
TUI_NEED_RIGHT=1
TUI_NEED_RESIZE=0
TUI_LEFT_TITLE="Haven Dashboard"
TUI_RIGHT_TITLE="Logs"
RIGHT_CONTENT_X=0
_SPINNER_TICK=0
TUI_MESSAGE_TITLE=""
TUI_MESSAGE_TEXT=""
CURRENT_ENV_KEY=""
CURRENT_JSON_FILE=""
LOG_FIFO=""
LOG_FD=""
LOG_PID=""
LOG_LINES=()
LOG_MAX_LINES=0
MENU_IDS=()
MENU_LABELS=()
MENU_TITLE=""
MENU_SUBTITLE=""
TUI_DOCKER_OK=0
TUI_LAST_DOCKER_CHECK=0
TUI_LAST_LOG_RESTART=0
TUI_NEED_MENU=1
_TRUNC=""
_ICON=""
_CRUMB=""
_KEY=""
_SANITIZED=""
_HLINE_LEFT=""
_HLINE_RIGHT=""
_HLINE_SEP=""
_BORDER_V=""

DOCKER_COMPOSE=()
COMPOSE_FILE_PLAIN="$ROOT_DIR/docker-compose.yml"
COMPOSE_FILE_TOR="$ROOT_DIR/docker-compose.tor.yml"

JSON_FILES=(
  "relays_import.json"
  "relays_blastr.json"
  "blacklisted_npubs.json"
  "whitelisted_npubs.json"
)

JSON_LABELS=(
  "Relays Import"
  "Relays Blastr"
  "Blacklisted npubs"
  "Whitelisted npubs"
)

json_label_for() {
  local file="$1"
  local count=${#JSON_FILES[@]}
  for ((i=0; i<count; i++)); do
    if [[ "${JSON_FILES[$i]}" == "$file" ]]; then
      printf "%s" "${JSON_LABELS[$i]}"
      return
    fi
  done
  printf "%s" "$file"
}

print_usage() {
  cat <<USAGE
Haven CLI & TUI

Usage:
  $SCRIPT_NAME [command] [options]

Commands:
  tui                 Open interactive TUI (default)
  start               Start relay (Docker Compose)
  stop                Stop services
  restart             Restart services
  logs                Stream logs
  status              Show status
  onion               Show Tor onion hostname (if available)
  import              Set HAVEN_IMPORT_FLAG (interactive)
  env                 Edit .env (TUI)
  env-upgrade         Add missing vars from .env.example
  json                Open JSON list editor
  help                Show this help

Options:
  -t, --tor            Use docker-compose.tor.yml
  --plain              Force docker-compose.yml
  --import             Set HAVEN_IMPORT_FLAG=true
  --no-import          Set HAVEN_IMPORT_FLAG=false
  --prompt-import      Ask for HAVEN_IMPORT_FLAG
  --tail N             Tail last N log lines (default: 100)
  -s, --service NAME   Logs: follow a specific service
  --all                Logs: follow all services
  --no-follow          Logs: do not follow (no -f)
  --no-build           Start/Restart without --build
  --build              Start/Restart with --build (default)
  -h, --help           Show this help

Examples:
  $SCRIPT_NAME
  $SCRIPT_NAME start
  $SCRIPT_NAME start --tor --prompt-import
  $SCRIPT_NAME logs --service relay --tail 200
  $SCRIPT_NAME json
  $SCRIPT_NAME env
USAGE
}

tui_update_layout() {
  TUI_COLS="$(tput cols 2>/dev/null || echo 80)"
  TUI_LINES="$(tput lines 2>/dev/null || echo 24)"

  LEFT_W=$((TUI_COLS * 38 / 100))
  if [[ "$LEFT_W" -lt 28 ]]; then
    LEFT_W=28
  fi
  if [[ "$LEFT_W" -gt $((TUI_COLS - 30)) ]]; then
    LEFT_W=$((TUI_COLS - 30))
  fi

  # Row 0: top border, Row 1: title bar, Row 2: separator
  # Rows 3..N-3: content, Row N-2: bottom border, Row N-1: status bar
  LEFT_X=2
  RIGHT_X=$((LEFT_W + 2))
  RIGHT_W=$((TUI_COLS - LEFT_W - 1))
  RIGHT_CONTENT_X=$((LEFT_W + 2))

  LEFT_CONTENT_W=$((LEFT_W - 3))
  RIGHT_CONTENT_W=$((TUI_COLS - LEFT_W - 4))
  if [[ "$LEFT_CONTENT_W" -lt 20 ]]; then
    LEFT_CONTENT_W=20
  fi
  if [[ "$RIGHT_CONTENT_W" -lt 20 ]]; then
    RIGHT_CONTENT_W=20
  fi

  LEFT_CONTENT_ROW=3
  RIGHT_CONTENT_ROW=3
  LEFT_CONTENT_HEIGHT=$((TUI_LINES - LEFT_CONTENT_ROW - 2))
  RIGHT_CONTENT_HEIGHT=$((TUI_LINES - RIGHT_CONTENT_ROW - 2))
  if [[ "$LEFT_CONTENT_HEIGHT" -lt 6 ]]; then
    LEFT_CONTENT_HEIGHT=6
  fi
  if [[ "$RIGHT_CONTENT_HEIGHT" -lt 6 ]]; then
    RIGHT_CONTENT_HEIGHT=6
  fi

  LOG_MAX_LINES=$RIGHT_CONTENT_HEIGHT

  # Pre-compute horizontal line strings and border for frame drawing
  printf -v _HLINE_LEFT '%*s' "$((LEFT_W - 1))" ''
  _HLINE_LEFT="${_HLINE_LEFT// /$BOX_H}"
  printf -v _HLINE_RIGHT '%*s' "$((TUI_COLS - LEFT_W - 2))" ''
  _HLINE_RIGHT="${_HLINE_RIGHT// /$BOX_H}"
  printf -v _HLINE_SEP '%*s' "$LEFT_CONTENT_W" ''
  _HLINE_SEP="${_HLINE_SEP// /$BOX_H}"
  printf -v _BORDER_V '%b%s%b' "$TUI_FG_SEPARATOR" "$BOX_V" "$CLR_RESET"
}

tui_init() {
  export LC_CTYPE="${LC_CTYPE:-en_US.UTF-8}"
  TUI_ACTIVE=1
  TUI_STTY_ORIG="$(stty -g)"
  stty -echo -icanon time 0 min 0
  tput smcup
  tput civis
  tui_update_layout
  trap 'tui_cleanup' EXIT
  trap 'tui_cleanup; exit 130' INT TERM
}

tui_cleanup() {
  stop_log_stream || true
  if [[ -n "$TUI_STTY_ORIG" ]]; then
    stty "$TUI_STTY_ORIG"
  fi
  tput cnorm 2>/dev/null || true
  tput rmcup 2>/dev/null || true
  TUI_ACTIVE=0
}

tui_read_key() {
  _KEY=""
  if ! IFS= read -rsn1 -t 0.05 _KEY; then
    return 1
  fi

  if [[ "$_KEY" == $'\x03' ]]; then
    _KEY="quit"
    return 0
  fi

  if [[ "$_KEY" == $'\x1b' ]]; then
    local seq=""
    IFS= read -rsn2 -t 0.01 seq || seq=""
    case "$seq" in
      "[A") _KEY="up" ;;
      "[B") _KEY="down" ;;
      "[C") _KEY="right" ;;
      "[D") _KEY="left" ;;
      *) _KEY="esc" ;;
    esac
    return 0
  fi

  if [[ -z "$_KEY" ]]; then
    _KEY="enter"
    return 0
  fi

  case "$_KEY" in
    $'\n'|$'\r') _KEY="enter" ;;
    q|Q) _KEY="quit" ;;
  esac
}

tui_clear() {
  tput clear
}

tui_draw_frame() {
  local do_clear="${1:-0}"
  local row
  local bottom_row=$((TUI_LINES - 2))
  if [[ "$do_clear" == "1" ]]; then
    tui_clear
  fi

  # Row 0: top border ┌───┬───┐
  printf '\033[1;1H'
  printf "%b%s%s%s%s%s%b" "$TUI_FG_SEPARATOR" \
    "$BOX_TL" "$_HLINE_LEFT" "$BOX_TT" "$_HLINE_RIGHT" "$BOX_TR" "$CLR_RESET"

  # Row 1: colored title bar
  printf '\033[2;1H'
  tui_truncate "$TUI_LEFT_TITLE" $((LEFT_W - 2))
  printf "%s%b %-*s%b%s%b" \
    "$_BORDER_V" "${TUI_BG_TITLEBAR}${TUI_BOLD}${TUI_FG_TITLE}" \
    "$((LEFT_W - 1))" "$_TRUNC" "$CLR_RESET" \
    "$_BORDER_V" "$CLR_RESET"
  tui_truncate "$TUI_RIGHT_TITLE" $((TUI_COLS - LEFT_W - 3))
  printf "%b %-*s%b%s" \
    "${TUI_BG_TITLEBAR}${TUI_BOLD}${TUI_FG_TITLE}" \
    "$((TUI_COLS - LEFT_W - 2))" "$_TRUNC" "$CLR_RESET" \
    "$_BORDER_V"

  # Row 2: sub-separator ├───┼───┤
  printf '\033[3;1H'
  printf "%b%s%s%s%s%s%b" "$TUI_FG_SEPARATOR" \
    "$BOX_LT" "$_HLINE_LEFT" "$BOX_CROSS" "$_HLINE_RIGHT" "$BOX_RT" "$CLR_RESET"

  # Content rows: left border, center divider, right border
  for ((row=3; row<bottom_row; row++)); do
    printf '\033[%d;1H%s\033[%d;%dH%s\033[%d;%dH%s' \
      "$((row+1))" "$_BORDER_V" \
      "$((row+1))" "$((LEFT_W+1))" "$_BORDER_V" \
      "$((row+1))" "$TUI_COLS" "$_BORDER_V"
  done

  # Bottom border └───┴───┘
  printf '\033[%d;1H' "$((bottom_row+1))"
  printf "%b%s%s%s%s%s%b" "$TUI_FG_SEPARATOR" \
    "$BOX_BL" "$_HLINE_LEFT" "$BOX_BT" "$_HLINE_RIGHT" "$BOX_BR" "$CLR_RESET"

  # Status bar
  tui_draw_status_bar
}

tui_draw_status_bar() {
  local status_row=$((TUI_LINES - 1))
  # Fill entire row with statusbar background first
  tput cup "$status_row" 0
  printf "%b%-*s%b" "${TUI_BG_STATUSBAR}" "$TUI_COLS" "" "$CLR_RESET"
  # Overlay hints text
  tput cup "$status_row" 1
  printf "%b %b↑↓%b%b Navigate  %b⏎%b%b Select  %b←%b%b Back  %bq%b%b Quit %b" \
    "${TUI_BG_STATUSBAR}" \
    "${TUI_FG_SHORTCUT}${TUI_BOLD}" "${CLR_RESET}${TUI_BG_STATUSBAR}${TUI_FG_STATUS}" \
    "" \
    "${TUI_FG_SHORTCUT}${TUI_BOLD}" "${CLR_RESET}${TUI_BG_STATUSBAR}${TUI_FG_STATUS}" \
    "" \
    "${TUI_FG_SHORTCUT}${TUI_BOLD}" "${CLR_RESET}${TUI_BG_STATUSBAR}${TUI_FG_STATUS}" \
    "" \
    "${TUI_FG_SHORTCUT}${TUI_BOLD}" "${CLR_RESET}${TUI_BG_STATUSBAR}${TUI_FG_STATUS}" \
    "" \
    "$CLR_RESET"
}

tui_truncate() {
  if (( ${#1} <= $2 )); then
    _TRUNC="$1"
  else
    local cutoff=$(($2 - 3))
    (( cutoff < 0 )) && cutoff=0
    _TRUNC="${1:0:$cutoff}..."
  fi
}

tui_print_left() {
  local row="$1"
  shift
  local text="$*"
  tput cup "$row" "$LEFT_X"
  printf "%-*s" "$LEFT_CONTENT_W" "$text"
}

tui_print_left_styled() {
  local row="$1"
  local style="$2"
  local text="$3"
  tput cup "$row" "$LEFT_X"
  printf "%b%-*s%b" "$style" "$LEFT_CONTENT_W" "$text" "$CLR_RESET"
}

tui_print_right() {
  local row="$1"
  shift
  local text="$*"
  tput cup "$row" "$RIGHT_X"
  printf "%-*s" "$RIGHT_CONTENT_W" "$text"
}

tui_wait_key() {
  local _=""
  while ! IFS= read -rsn1 -t 0.1 _; do :; done
}

tui_prompt() {
  local prompt="$1"
  local default="$2"
  local input=""
  local ch=""
  local prompt_row=$((TUI_LINES - 3))
  local prompt_len=${#prompt}
  local max_input=$((LEFT_CONTENT_W - prompt_len - 2))
  (( max_input < 10 )) && max_input=10

  # Flush any pending input
  while IFS= read -rsn1 -t 0.01 _ </dev/tty; do :; done

  # All display output goes to /dev/tty so it reaches the terminal
  # even when this function runs inside $() subshell capture
  {
    tput cup "$prompt_row" "$LEFT_X"
    printf "%-*s" "$LEFT_CONTENT_W" ""
    tput cup "$prompt_row" "$LEFT_X"
    printf "%b%s%b " "${TUI_FG_ACCENT}" "$prompt" "$CLR_RESET"
    tput cnorm
  } >/dev/tty

  while true; do
    IFS= read -rsn1 -t 0.1 ch </dev/tty || continue

    # ESC → cancel
    if [[ "$ch" == $'\x1b' ]]; then
      # Consume any trailing escape sequence chars
      IFS= read -rsn2 -t 0.01 _ </dev/tty || true
      input="$default"
      break
    fi

    # Enter → confirm
    if [[ -z "$ch" || "$ch" == $'\n' || "$ch" == $'\r' ]]; then
      if [[ -z "$input" ]]; then
        input="$default"
      fi
      break
    fi

    # Backspace (0x7f or 0x08)
    if [[ "$ch" == $'\x7f' || "$ch" == $'\x08' ]]; then
      if [[ -n "$input" ]]; then
        input="${input%?}"
        # Redraw input area
        {
          tput cup "$prompt_row" "$((LEFT_X + prompt_len + 1))"
          printf "%-*s" "$max_input" "$input"
          tput cup "$prompt_row" "$((LEFT_X + prompt_len + 1 + ${#input}))"
        } >/dev/tty
      fi
      continue
    fi

    # Ctrl-C → cancel
    if [[ "$ch" == $'\x03' ]]; then
      input="$default"
      break
    fi

    # Append printable character
    if (( ${#input} < max_input )); then
      input+="$ch"
      printf "%s" "$ch" >/dev/tty
    fi
  done

  tput civis >/dev/tty
  printf "%s" "$input"
}

tui_confirm() {
  local prompt="$1"
  local default_answer="$2"
  local selection=0

  if [[ "$default_answer" == "n" || "$default_answer" == "N" ]]; then
    selection=1
  fi

  local yes_label="  Yes  "
  local no_label="  No  "
  local row=$((LEFT_CONTENT_ROW + 2))

  tui_draw_frame 1
  tui_render_right_logs
  tui_print_left_styled "$LEFT_CONTENT_ROW" "${TUI_BOLD}${TUI_FG_ACCENT}" "$prompt"

  while true; do
    tput cup "$row" "$LEFT_X"
    printf "%-*s" "$LEFT_CONTENT_W" ""
    tput cup "$row" "$LEFT_X"
    if [[ "$selection" -eq 0 ]]; then
      printf "%b%s%b  %b%s%b" \
        "${TUI_BOLD}${TUI_FG_SELECTED}${TUI_BG_CONFIRM_YES}" "$yes_label" "$CLR_RESET" \
        "${TUI_DIM}${TUI_FG_MENU_DIM}" "$no_label" "$CLR_RESET"
    else
      printf "%b%s%b  %b%s%b" \
        "${TUI_DIM}${TUI_FG_MENU_DIM}" "$yes_label" "$CLR_RESET" \
        "${TUI_BOLD}${TUI_FG_SELECTED}${TUI_BG_CONFIRM_NO}" "$no_label" "$CLR_RESET"
    fi

    tui_read_key || continue
    case "$_KEY" in
      left|up) selection=0 ;;
      right|down) selection=1 ;;
      enter)
        if [[ "$selection" -eq 0 ]]; then
          return 0
        fi
        return 1
        ;;
      esc) return 1 ;;
    esac
  done
}

tui_message() {
  local title="$1"
  local text="$2"
  local row="$LEFT_CONTENT_ROW"
  tui_draw_frame 1
  tui_render_right_logs

  # Bold accent title
  tui_print_left_styled "$row" "${TUI_BOLD}${TUI_FG_ACCENT}" "$title"
  row=$((row + 1))

  # Thin separator
  tui_print_left_styled "$row" "$TUI_FG_SEPARATOR" "$_HLINE_SEP"
  row=$((row + 1))

  # Body text
  local line
  while IFS= read -r line; do
    if [[ "$row" -ge $((LEFT_CONTENT_ROW + LEFT_CONTENT_HEIGHT)) ]]; then
      break
    fi
    tui_print_left "$row" "$line"
    row=$((row + 1))
  done < <(printf "%s" "$text" | fold -s -w "$LEFT_CONTENT_W")

  # Dim footer
  tui_print_left_styled $((LEFT_CONTENT_ROW + LEFT_CONTENT_HEIGHT - 1)) "$TUI_DIM" "Press any key to continue."
  tui_wait_key
}

info() {
  printf "%b\n" "${CLR_BLUE}INFO${CLR_RESET} $*"
}

success() {
  printf "%b\n" "${CLR_GREEN}OK${CLR_RESET} $*"
}

warn() {
  printf "%b\n" "${CLR_YELLOW}WARN${CLR_RESET} $*"
}

die() {
  printf "%b\n" "${CLR_RED}ERROR${CLR_RESET} $*" >&2
  exit 1
}

ensure_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"
}

detect_compose() {
  ensure_cmd docker
  if docker compose version >/dev/null 2>&1; then
    DOCKER_COMPOSE=(docker compose)
    return
  fi
  if command -v docker-compose >/dev/null 2>&1; then
    DOCKER_COMPOSE=(docker-compose)
    return
  fi
  die "Docker Compose not found. Install Docker Compose v2 or docker-compose."
}

ensure_docker() {
  if ! docker info >/dev/null 2>&1; then
    die "Docker daemon not reachable. Is Docker running?"
  fi
}

tui_require_docker() {
  if docker info >/dev/null 2>&1; then
    return 0
  fi
  if [[ "$TUI_ACTIVE" == "1" ]]; then
    tui_message "Docker" "Docker daemon not reachable. Start Docker and try again."
  else
    warn "Docker daemon not reachable. Start Docker and try again."
  fi
  return 1
}

has_tor_container() {
  docker ps -a --format '{{.Names}}' | grep -qx 'haven-tor'
}

resolve_mode() {
  local action="$1"
  if [[ "$MODE" == "tor" ]]; then
    printf '%s' "tor"
    return
  fi
  if [[ "$MODE" == "plain" ]]; then
    printf '%s' "plain"
    return
  fi
  if [[ "$action" == "start" ]]; then
    printf '%s' "plain"
    return
  fi
  if has_tor_container; then
    printf '%s' "tor"
  else
    printf '%s' "plain"
  fi
}

compose_file_for() {
  local mode="$1"
  if [[ "$mode" == "tor" ]]; then
    printf '%s' "$COMPOSE_FILE_TOR"
  else
    printf '%s' "$COMPOSE_FILE_PLAIN"
  fi
}

require_compose_file() {
  [[ -f "$1" ]] || die "Compose file not found: $1"
}

dc() {
  local compose_file="$1"
  shift
  "${DOCKER_COMPOSE[@]}" -f "$compose_file" "$@"
}

read_env_var() {
  local key="$1"
  local env_file="$ROOT_DIR/.env"
  [[ -f "$env_file" ]] || return 1
  awk -v key="$key" '
    function strip_inline(v,    i,c,quote,out) {
      quote=""
      out=""
      for (i=1; i<=length(v); i++) {
        c=substr(v,i,1)
        if (c=="\"" || c=="\047") {
          if (quote==c) quote=""
          else if (quote=="") quote=c
        }
        if (c=="#" && quote=="") break
        out=out c
      }
      sub(/[ \t]+$/, "", out)
      return out
    }
    $0 ~ "^[ \t]*export[ \t]+" key "=" {
      line=$0
      sub(/^[ \t]*export[ \t]+/, "", line)
      sub(/^[^=]+=*/, "", line)
      print strip_inline(line)
      found=1
      next
    }
    $0 ~ "^" key "=" {
      line=$0
      sub(/^[^=]+=*/, "", line)
      print strip_inline(line)
      found=1
      next
    }
    END {if(!found) exit 1}
  ' "$env_file"
}

set_env_var() {
  local key="$1"
  local value="$2"
  local env_file="$ROOT_DIR/.env"
  local tmp_file="$env_file.tmp"

  if [[ ! -f "$env_file" ]]; then
    touch "$env_file"
  else
    cp "$env_file" "$env_file.bak"
  fi

  awk -v key="$key" -v value="$value" '
    BEGIN { found=0 }
    $0 ~ "^[ \t]*export[ \t]+" key "=" { print "export " key "=" value; found=1; next }
    $0 ~ "^" key "=" { print key "=" value; found=1; next }
    { print }
    END { if (!found) print key "=" value }
  ' "$env_file" > "$tmp_file"

  mv "$tmp_file" "$env_file"
}

run_capture() {
  RUN_OUTPUT=""
  RUN_STATUS=0
  set +e
  RUN_OUTPUT="$("$@" 2>&1)"
  RUN_STATUS=$?
  set -e
}

is_quoted() {
  local raw="$1"
  [[ ${#raw} -ge 2 ]] || return 1
  local first="${raw:0:1}"
  local last="${raw: -1}"
  [[ ( "$first" == "\"" && "$last" == "\"" ) || ( "$first" == "'" && "$last" == "'" ) ]]
}

strip_quotes() {
  local raw="$1"
  if is_quoted "$raw"; then
    printf "%s" "${raw:1:${#raw}-2}"
  else
    printf "%s" "$raw"
  fi
}

wrap_like_raw() {
  local raw="$1"
  local value="$2"
  if is_quoted "$raw"; then
    local quote="${raw:0:1}"
    printf "%s%s%s" "$quote" "$value" "$quote"
  else
    printf "%s" "$value"
  fi
}

value_has_unquoted_spaces() {
  local raw="$1"
  if is_quoted "$raw"; then
    return 1
  fi
  [[ "$raw" =~ [[:space:]] ]]
}

is_int() {
  [[ "$1" =~ ^[0-9]+$ ]]
}

is_port() {
  local value="$1"
  is_int "$value" || return 1
  [[ "$value" -ge 1 && "$value" -le 65535 ]]
}

is_bool() {
  local value="${1,,}"
  [[ "$value" == "true" || "$value" == "false" ]]
}

is_mixed_case() {
  [[ "$1" =~ [a-z] ]] && [[ "$1" =~ [A-Z] ]]
}

is_npub() {
  local value="${1,,}"
  [[ "$value" =~ ^npub1[023456789acdefghjklmnpqrstuvwxyz]+$ ]]
}

is_relay_address() {
  local value="$1"
  [[ -n "$value" ]] || return 1
  [[ "$value" =~ [[:space:]] ]] && return 1
  [[ "$value" =~ ^([a-zA-Z][a-zA-Z0-9+.-]*://)?(\\[[0-9a-fA-F:]+\\]|[A-Za-z0-9.-]+)(:[0-9]{1,5})?(/.*)?$ ]]
}

is_http_url() {
  local value="$1"
  [[ "$value" =~ ^https?://.+$ ]]
}

is_date() {
  [[ "$1" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]
}

is_duration() {
  [[ "$1" =~ ^[0-9]+[smhd]$ ]]
}

is_log_level() {
  case "${1^^}" in
    DEBUG|INFO|WARNING|ERROR) return 0 ;;
    *) return 1 ;;
  esac
}

is_backup_provider() {
  case "${1,,}" in
    ""|none|s3) return 0 ;;
    *) return 1 ;;
  esac
}

is_ipv4() {
  local value="$1"
  [[ "$value" =~ ^([0-9]{1,3}\\.){3}[0-9]{1,3}$ ]] || return 1
  local o1 o2 o3 o4
  IFS=. read -r o1 o2 o3 o4 <<<"$value"
  for octet in "$o1" "$o2" "$o3" "$o4"; do
    [[ "$octet" -ge 0 && "$octet" -le 255 ]] || return 1
  done
}

is_ipv6() {
  local value="$1"
  [[ "$value" =~ : ]] || return 1
  [[ "$value" =~ ^[0-9a-fA-F:]+$ ]]
}

ensure_json_file_value() {
  local raw="$1"
  local allow_empty="$2"
  local value="$3"

  if [[ -z "$value" ]]; then
    [[ "$allow_empty" == "1" ]] && return 0
    VALIDATION_ERROR="Value cannot be empty."
    return 1
  fi

  if [[ "$value" != *.json ]]; then
    VALIDATION_ERROR="File must end with .json"
    return 1
  fi

  local path="$ROOT_DIR/$value"
  if [[ -f "$path" ]]; then
    return 0
  fi

  if [[ -t 0 && -t 1 ]]; then
    if ask_yes_no "File $value not found. Create empty file now? [y/N] " "n"; then
      printf "[]\n" > "$path"
      success "Created $value"
      return 0
    fi
  fi

  VALIDATION_ERROR="File not found: $value"
  return 1
}

validate_env_value() {
  local key="$1"
  local raw="$2"
  local value=""
  local provider=""

  VALIDATION_ERROR=""
  VALIDATION_VALUE="$raw"

  if [[ -n "$raw" ]]; then
    value="$(strip_quotes "$raw")"
  fi

  if value_has_unquoted_spaces "$raw"; then
    VALIDATION_ERROR="Values with spaces must be quoted."
    return 1
  fi

  case "$key" in
    *_NPUB|OWNER_NPUB|PRIVATE_RELAY_NPUB|CHAT_RELAY_NPUB|OUTBOX_RELAY_NPUB|INBOX_RELAY_NPUB)
      if [[ -z "$value" ]]; then
        VALIDATION_ERROR="NPUB cannot be empty."
        return 1
      fi
      if is_mixed_case "$value"; then
        VALIDATION_ERROR="NPUB must be all lowercase or all uppercase."
        return 1
      fi
      if ! is_npub "$value"; then
        VALIDATION_ERROR="Invalid npub format."
        return 1
      fi
      VALIDATION_VALUE="$(wrap_like_raw "$raw" "${value,,}")"
      ;;
    RELAY_URL)
      if ! is_relay_address "$value"; then
        VALIDATION_ERROR="Invalid relay host or URL."
        return 1
      fi
      ;;
    RELAY_PORT)
      if ! is_port "$value"; then
        VALIDATION_ERROR="Port must be 1-65535."
        return 1
      fi
      VALIDATION_VALUE="$value"
      ;;
    RELAY_BIND_ADDRESS)
      if [[ -z "$value" ]]; then
        VALIDATION_VALUE="$raw"
        return 0
      fi
      if ! is_ipv4 "$value" && ! is_ipv6 "$value"; then
        VALIDATION_ERROR="Bind address must be IPv4, IPv6, or empty."
        return 1
      fi
      ;;
    DB_ENGINE)
      case "${value,,}" in
        badger|lmdb) VALIDATION_VALUE="$(wrap_like_raw "$raw" "${value,,}")" ;;
        *) VALIDATION_ERROR="DB_ENGINE must be badger or lmdb."; return 1 ;;
      esac
      ;;
    LMDB_MAPSIZE)
      if ! is_int "$value"; then
        VALIDATION_ERROR="LMDB_MAPSIZE must be a number >= 0."
        return 1
      fi
      VALIDATION_VALUE="$value"
      ;;
    BLOSSOM_PATH)
      if [[ -z "$value" ]]; then
        VALIDATION_ERROR="BLOSSOM_PATH cannot be empty."
        return 1
      fi
      ;;
    *_ICON)
      if [[ -n "$value" ]] && ! is_http_url "$value"; then
        VALIDATION_ERROR="Icon must be a http(s) URL or empty."
        return 1
      fi
      ;;
    *_ALLOW_EMPTY_FILTERS|*_ALLOW_COMPLEX_FILTERS)
      if ! is_bool "$value"; then
        VALIDATION_ERROR="Value must be true or false."
        return 1
      fi
      VALIDATION_VALUE="${value,,}"
      ;;
    *_TOKENS_PER_INTERVAL|*_INTERVAL|*_MAX_TOKENS|*_INTERVAL_SECONDS|*_TIMEOUT_SECONDS|*_DEPTH|*_MINIMUM_FOLLOWERS|*_INTERVAL_HOURS|INBOX_PULL_INTERVAL_SECONDS)
      if ! is_int "$value"; then
        VALIDATION_ERROR="Value must be a number >= 0."
        return 1
      fi
      VALIDATION_VALUE="$value"
      ;;
    IMPORT_START_DATE)
      if ! is_date "$value"; then
        VALIDATION_ERROR="Date must be YYYY-MM-DD."
        return 1
      fi
      ;;
    IMPORT_SEED_RELAYS_FILE)
      ensure_json_file_value "$raw" 0 "$value" || return 1
      ;;
    BLASTR_RELAYS_FILE)
      ensure_json_file_value "$raw" 0 "$value" || return 1
      ;;
    WHITELISTED_NPUBS_FILE|BLACKLISTED_NPUBS_FILE)
      ensure_json_file_value "$raw" 1 "$value" || return 1
      ;;
    BACKUP_PROVIDER)
      if ! is_backup_provider "$value"; then
        VALIDATION_ERROR="BACKUP_PROVIDER must be s3, none, or empty."
        return 1
      fi
      VALIDATION_VALUE="$(wrap_like_raw "$raw" "${value,,}")"
      ;;
    BACKUP_INTERVAL_HOURS)
      if ! is_int "$value"; then
        VALIDATION_ERROR="BACKUP_INTERVAL_HOURS must be a number >= 0."
        return 1
      fi
      VALIDATION_VALUE="$value"
      ;;
    S3_ACCESS_KEY_ID|S3_SECRET_KEY|S3_ENDPOINT|S3_REGION|S3_BUCKET_NAME)
      provider="$(read_env_var BACKUP_PROVIDER 2>/dev/null || true)"
      provider="$(strip_quotes "$provider")"
      provider="${provider,,}"
      if [[ "$provider" == "s3" && -z "$value" ]]; then
        VALIDATION_ERROR="$key is required when BACKUP_PROVIDER=s3."
        return 1
      fi
      if [[ "$key" == "S3_ENDPOINT" && -n "$value" ]]; then
        if ! is_relay_address "$value"; then
          VALIDATION_ERROR="S3_ENDPOINT must be a host or URL."
          return 1
        fi
      fi
      if [[ "$key" == "S3_BUCKET_NAME" && -n "$value" ]]; then
        if [[ ! "$value" =~ ^[a-z0-9.-]{3,63}$ ]]; then
          VALIDATION_ERROR="S3_BUCKET_NAME must be 3-63 chars (lowercase, numbers, dot, dash)."
          return 1
        fi
      fi
      ;;
    WOT_REFRESH_INTERVAL)
      if ! is_duration "$value"; then
        VALIDATION_ERROR="WOT_REFRESH_INTERVAL must look like 24h, 30m, or 10s."
        return 1
      fi
      ;;
    HAVEN_LOG_LEVEL)
      if ! is_log_level "$value"; then
        VALIDATION_ERROR="HAVEN_LOG_LEVEL must be DEBUG, INFO, WARNING, or ERROR."
        return 1
      fi
      VALIDATION_VALUE="$(wrap_like_raw "$raw" "${value^^}")"
      ;;
    *)
      ;;
  esac

  return 0
}

ask_yes_no() {
  local prompt="$1"
  local default_answer="$2"
  local reply=""

  if [[ "$TUI_ACTIVE" == "1" && -t 1 ]]; then
    if tui_confirm "$prompt" "$default_answer"; then
      return 0
    fi
    return 1
  fi

  while true; do
    read -r -p "$prompt" reply
    if [[ -z "$reply" ]]; then
      reply="$default_answer"
    fi
    case "$reply" in
      y|Y|yes|YES) return 0 ;;
      n|N|no|NO) return 1 ;;
      *) printf "Please answer y or n.\n" ;;
    esac
  done
}

prompt_import_flag() {
  local current=""
  local default_answer="n"
  local prompt="Import old notes on next start? [y/N] "

  if current="$(read_env_var HAVEN_IMPORT_FLAG 2>/dev/null)"; then
    current="${current,,}"
  fi

  if [[ "$current" == "true" ]]; then
    default_answer="y"
    prompt="Import old notes on next start? [Y/n] "
  fi

  if ask_yes_no "$prompt" "$default_answer"; then
    set_env_var HAVEN_IMPORT_FLAG true
    success "HAVEN_IMPORT_FLAG set to true"
  else
    set_env_var HAVEN_IMPORT_FLAG false
    success "HAVEN_IMPORT_FLAG set to false"
  fi
}

apply_import_flag() {
  case "$IMPORT_MODE" in
    true)
      set_env_var HAVEN_IMPORT_FLAG true
      success "HAVEN_IMPORT_FLAG set to true"
      ;;
    false)
      set_env_var HAVEN_IMPORT_FLAG false
      success "HAVEN_IMPORT_FLAG set to false"
      ;;
    prompt)
      prompt_import_flag
      ;;
    auto)
      if [[ "$SKIP_IMPORT_PROMPT" == "0" && -t 0 && -t 1 ]]; then
        prompt_import_flag
      fi
      ;;
  esac
}

ensure_example_jsons() {
  local example
  for example in "$ROOT_DIR"/*.example.json; do
    [[ -e "$example" ]] || continue
    local target="${example/.example.json/.json}"
    if [[ ! -f "$target" ]]; then
      local example_name
      local target_name
      example_name="$(basename "$example")"
      target_name="$(basename "$target")"
      if [[ -t 0 && -t 1 ]]; then
        if ask_yes_no "Missing $target_name. Copy from $example_name now? [Y/n] " "y"; then
          cp "$example" "$target"
          success "Created $target_name"
        else
          warn "Skipped $target_name. You can copy it later."
        fi
      else
        warn "Missing $target_name. Run: cp $example_name $target_name"
      fi
    fi
  done
}

ensure_templates_dir() {
  local src="$ROOT_DIR/templates-example"
  local dst="$ROOT_DIR/templates"
  local needs_copy=0

  [[ -d "$src" ]] || return 0

  if [[ ! -d "$dst" ]]; then
    needs_copy=1
  else
    if [[ -z "$(find "$dst" -mindepth 1 -maxdepth 1 -print -quit 2>/dev/null)" ]]; then
      needs_copy=1
    fi
  fi

  if [[ "$needs_copy" == "1" ]]; then
    if [[ -t 0 && -t 1 ]]; then
      if ask_yes_no "Templates missing. Copy templates-example -> templates now? [Y/n] " "y"; then
        mkdir -p "$dst"
        cp -R "$src"/. "$dst"/
        success "Templates copied."
      else
        warn "Templates not copied. Start may fail."
      fi
    else
      warn "Templates missing. Run: cp -R templates-example/. templates/"
    fi
  fi
}

detect_json_tool() {
  if command -v jq >/dev/null 2>&1; then
    JSON_TOOL="jq"
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    JSON_TOOL="python"
    return 0
  fi
  warn "Missing dependency: jq or python3 (needed for JSON editor)."
  return 1
}

ensure_env_file() {
  local env_file="$ROOT_DIR/.env"
  if [[ -f "$env_file" ]]; then
    return 0
  fi

  if [[ -t 0 && -t 1 ]]; then
    if ask_yes_no ".env not found. Create empty .env now? [Y/n] " "y"; then
      touch "$env_file"
      success "Created .env"
      return 0
    fi
    warn ".env missing."
    return 1
  fi

  warn ".env missing. Create one before editing."
  return 1
}

list_env_keys() {
  local env_file="$ROOT_DIR/.env"
  [[ -f "$env_file" ]] || return 0
  awk '
    /^[ \t]*#/ {next}
    /^[ \t]*$/ {next}
    /^[ \t]*export[ \t]+[A-Za-z_][A-Za-z0-9_]*=/ {
      line=$0
      sub(/^[ \t]*export[ \t]+/, "", line)
      split(line, a, "=")
      key=a[1]
      if (!(key in seen)) { print key; seen[key]=1 }
      next
    }
    /^[A-Za-z_][A-Za-z0-9_]*=/ {
      split($0, a, "=")
      key=a[1]
      if (!(key in seen)) { print key; seen[key]=1 }
    }
  ' "$env_file"
}

remove_env_var() {
  local key="$1"
  local env_file="$ROOT_DIR/.env"
  local tmp_file="$env_file.tmp"
  [[ -f "$env_file" ]] || return 1
  cp "$env_file" "$env_file.bak"
  awk -v key="$key" '
    $0 ~ "^[ \t]*export[ \t]+" key "=" { next }
    $0 ~ "^" key "=" { next }
    { print }
  ' "$env_file" > "$tmp_file"
  mv "$tmp_file" "$env_file"
}

list_missing_env_vars() {
  local env_file="$ROOT_DIR/.env"
  local example_file="$ROOT_DIR/.env.example"
  [[ -f "$env_file" && -f "$example_file" ]] || return 0
  awk '
    function extract_key(line,    tmp, ep, kp) {
      tmp = line
      sub(/^[ \t]*/, "", tmp)
      sub(/^export[ \t]+/, "", tmp)
      ep = index(tmp, "=")
      if (ep == 0) return ""
      kp = substr(tmp, 1, ep - 1)
      if (kp ~ /^[A-Za-z_][A-Za-z0-9_]*$/) return kp
      return ""
    }
    NR == FNR {
      key = extract_key($0)
      if (key != "") existing[key] = 1
      next
    }
    {
      key = extract_key($0)
      if (key != "" && !(key in existing)) print key
    }
  ' "$env_file" "$example_file"
}

upgrade_env_file() {
  local env_file="$ROOT_DIR/.env"
  local example_file="$ROOT_DIR/.env.example"
  local tmp_file="$env_file.tmp"

  [[ -f "$example_file" ]] || return 1

  if [[ ! -f "$env_file" ]]; then
    cp "$example_file" "$env_file"
    return 0
  fi

  cp "$env_file" "$env_file.bak"

  awk '
    function extract_key(line,    tmp, ep, kp) {
      tmp = line
      sub(/^[ \t]*/, "", tmp)
      sub(/^export[ \t]+/, "", tmp)
      ep = index(tmp, "=")
      if (ep == 0) return ""
      kp = substr(tmp, 1, ep - 1)
      if (kp ~ /^[A-Za-z_][A-Za-z0-9_]*$/) return kp
      return ""
    }

    NR == FNR {
      key = extract_key($0)
      if (key != "") existing[key] = 1
      env_lines[++env_count] = $0
      next
    }

    {
      key = extract_key($0)
      if (key != "") {
        if (key in existing) {
          last_anchor = key
          has_gap = 0
        } else {
          n_missing++
          insert_after[n_missing] = last_anchor
          if (has_gap) {
            insert_block[n_missing] = "\n" $0 "\n"
          } else {
            insert_block[n_missing] = $0 "\n"
          }
          has_gap = 0
        }
      } else {
        has_gap = 1
      }
    }

    END {
      for (j = 1; j <= n_missing; j++) {
        if (insert_after[j] == "") {
          printf "%s", insert_block[j]
        }
      }
      for (i = 1; i <= env_count; i++) {
        print env_lines[i]
        key = extract_key(env_lines[i])
        if (key != "") {
          for (j = 1; j <= n_missing; j++) {
            if (insert_after[j] == key) {
              printf "%s", insert_block[j]
            }
          }
        }
      }
    }
  ' "$env_file" "$example_file" > "$tmp_file"

  mv "$tmp_file" "$env_file"
}

ensure_json_array_file() {
  local file="$1"
  local path="$ROOT_DIR/$file"
  local example="$ROOT_DIR/${file/.json/.example.json}"

  if [[ -f "$path" ]]; then
    return 0
  fi

  if [[ -f "$example" ]]; then
    if ask_yes_no "Create $file from $(basename "$example")? [Y/n] " "y"; then
      cp "$example" "$path"
      success "Created $file"
      return 0
    fi
  fi

  if ask_yes_no "$file is missing. Create empty list now? [Y/n] " "y"; then
    printf "[]\n" > "$path"
    success "Created $file"
  else
    warn "JSON file missing: $file"
    return 1
  fi
}

json_list_items() {
  local path="$1"
  if [[ "$JSON_TOOL" == "jq" ]]; then
    jq -e 'type=="array"' "$path" >/dev/null 2>&1 || die "Invalid JSON array in $(basename "$path")"
    jq -r '.[]' "$path"
  else
    python3 - "$path" <<'PY'
import json,sys
path=sys.argv[1]
with open(path,"r",encoding="utf-8") as f:
    data=json.load(f)
if not isinstance(data,list):
    raise SystemExit(1)
for item in data:
    print(item)
PY
  fi
}

json_write_tmp() {
  local path="$1"
  local tmp="$path.tmp"
  cat > "$tmp"
  mv "$tmp" "$path"
}

json_add_item() {
  local path="$1"
  local item="$2"
  if [[ "$JSON_TOOL" == "jq" ]]; then
    jq --arg item "$item" '. + [$item]' "$path" | json_write_tmp "$path"
  else
    python3 - "$path" "$item" <<'PY'
import json,sys,os
path=sys.argv[1]
item=sys.argv[2]
with open(path,"r",encoding="utf-8") as f:
    data=json.load(f)
if not isinstance(data,list):
    raise SystemExit(1)
data.append(item)
with open(path+".tmp","w",encoding="utf-8") as f:
    json.dump(data,f,ensure_ascii=True,indent=2)
    f.write("\n")
os.replace(path+".tmp",path)
PY
  fi
}

json_remove_index() {
  local path="$1"
  local index="$2"
  if [[ "$JSON_TOOL" == "jq" ]]; then
    jq --argjson idx "$index" 'del(.[$idx])' "$path" | json_write_tmp "$path"
  else
    python3 - "$path" "$index" <<'PY'
import json,sys,os
path=sys.argv[1]
index=int(sys.argv[2])
with open(path,"r",encoding="utf-8") as f:
    data=json.load(f)
if not isinstance(data,list):
    raise SystemExit(1)
if index < 0 or index >= len(data):
    raise SystemExit(2)
data.pop(index)
with open(path+".tmp","w",encoding="utf-8") as f:
    json.dump(data,f,ensure_ascii=True,indent=2)
    f.write("\n")
os.replace(path+".tmp",path)
PY
  fi
}

json_clear() {
  local path="$1"
  if [[ "$JSON_TOOL" == "jq" ]]; then
    printf "[]\n" | json_write_tmp "$path"
  else
    printf "[]\n" > "$path"
  fi
}

json_item_kind() {
  local file="$1"
  case "$file" in
    relays_import.json|relays_blastr.json) printf "relay" ;;
    blacklisted_npubs.json|whitelisted_npubs.json) printf "npub" ;;
    *) printf "string" ;;
  esac
}

json_item_is_valid() {
  local file="$1"
  local item="$2"
  local kind
  kind="$(json_item_kind "$file")"

  case "$kind" in
    relay)
      is_relay_address "$item"
      ;;
    npub)
      if is_mixed_case "$item"; then
        return 1
      fi
      is_npub "$item"
      ;;
    *)
      [[ -n "$item" ]]
      ;;
  esac
}

validate_json_item() {
  local file="$1"
  local item="$2"
  local kind
  kind="$(json_item_kind "$file")"

  VALIDATION_VALUE="$item"
  if [[ -z "$item" ]]; then
    VALIDATION_ERROR="Item cannot be empty."
    return 1
  fi

  case "$kind" in
    relay)
      if ! is_relay_address "$item"; then
        VALIDATION_ERROR="Relay must be a host or URL."
        return 1
      fi
      ;;
    npub)
      if is_mixed_case "$item"; then
        VALIDATION_ERROR="NPUB must be all lowercase or all uppercase."
        return 1
      fi
      if ! is_npub "$item"; then
        VALIDATION_ERROR="Invalid npub format."
        return 1
      fi
      VALIDATION_VALUE="${item,,}"
      ;;
    *)
      ;;
  esac

  return 0
}

list_services() {
  local compose_file="$1"
  dc "$compose_file" config --services 2>/dev/null || true
}

show_onion_host() {
  local host_file="$ROOT_DIR/tor/data/haven/hostname"
  if [[ -f "$host_file" ]]; then
    printf "Onion Host: %s\n" "$(cat "$host_file")"
  else
    warn "Onion host file not found. Tor may still be initializing."
  fi
}

prepare_start() {
  ensure_templates_dir
  ensure_example_jsons
  apply_import_flag
}

start_services() {
  local mode="$1"
  local compose_file
  local args=(up -d)

  compose_file="$(compose_file_for "$mode")"
  require_compose_file "$compose_file"

  prepare_start

  if [[ "$BUILD_IMAGES" == "1" ]]; then
    args+=(--build)
  fi

  info "Starting services ($mode)..."
  dc "$compose_file" "${args[@]}"
  dc "$compose_file" ps

  if [[ "$mode" == "tor" ]]; then
    show_onion_host
  fi
}

stop_services() {
  local mode="$1"
  local compose_file
  compose_file="$(compose_file_for "$mode")"
  require_compose_file "$compose_file"

  info "Stopping services ($mode)..."
  if ! dc "$compose_file" down --remove-orphans; then
    warn "Nothing to stop or compose down failed."
  fi
}

restart_services() {
  local mode="$1"
  stop_services "$mode"
  start_services "$mode"
}

show_status() {
  local mode="$1"
  local compose_file
  compose_file="$(compose_file_for "$mode")"
  require_compose_file "$compose_file"

  info "Status ($mode):"
  dc "$compose_file" ps

  if [[ "$mode" == "tor" ]]; then
    show_onion_host
  fi
}

stream_logs() {
  local mode="$1"
  local compose_file="$2"
  local service="$3"
  local args=(logs --tail "$TAIL_COUNT")

  if [[ "$FOLLOW_LOGS" == "1" ]]; then
    args+=(-f)
  fi

  if [[ -n "$service" && "$service" != "all" ]]; then
    args+=("$service")
  fi

  info "Streaming logs ($mode). Press Ctrl+C to return."
  dc "$compose_file" "${args[@]}"
}

log_sanitize_line() {
  _SANITIZED="$1"
  _SANITIZED="${_SANITIZED//$'\r'/}"
  _SANITIZED="${_SANITIZED//$'\t'/  }"
  # Strip ANSI escape sequences using pure bash
  while [[ "$_SANITIZED" == *$'\x1b\x5b'* ]]; do
    local _before="${_SANITIZED%%$'\x1b\x5b'*}"
    local _after="${_SANITIZED#*$'\x1b\x5b'}"
    while [[ "${_after:0:1}" == [0-9\;] ]]; do
      _after="${_after:1}"
    done
    [[ "${_after:0:1}" == [a-zA-Z] ]] && _after="${_after:1}"
    _SANITIZED="${_before}${_after}"
  done
}

log_append() {
  local line="$1"
  LOG_LINES+=("$line")
  if (( ${#LOG_LINES[@]} > LOG_MAX_LINES )); then
    LOG_LINES=("${LOG_LINES[@]: -$LOG_MAX_LINES}")
  fi
}

stop_log_stream() {
  if [[ -n "$LOG_PID" ]]; then
    kill "$LOG_PID" >/dev/null 2>&1 || true
    wait "$LOG_PID" >/dev/null 2>&1 || true
  fi
  LOG_PID=""
  if [[ -n "${LOG_FD:-}" ]]; then
    exec {LOG_FD}<&- || true
  fi
  LOG_FD=""
  if [[ -n "$LOG_FIFO" ]]; then
    rm -f "$LOG_FIFO"
  fi
  LOG_FIFO=""
}

start_log_stream() {
  stop_log_stream
  LOG_LINES=()

  if ! docker info >/dev/null 2>&1; then
    return
  fi

  local mode
  local compose_file
  local args=(logs --tail "$TAIL_COUNT")
  mode="$(resolve_mode "logs")"
  compose_file="$(compose_file_for "$mode")"

  if [[ ! -f "$compose_file" ]]; then
    log_append "Compose file not found: $(basename "$compose_file")"
    return
  fi

  if [[ "$FOLLOW_LOGS" == "1" ]]; then
    args+=(-f)
  fi
  if [[ -n "$LOG_SERVICE" && "$LOG_SERVICE" != "all" ]]; then
    args+=("$LOG_SERVICE")
  fi

  LOG_FIFO="$(mktemp -u)"
  mkfifo "$LOG_FIFO"
  set +e
  dc "$compose_file" "${args[@]}" >"$LOG_FIFO" 2>&1 &
  LOG_PID=$!
  set -e
  exec {LOG_FD}<"$LOG_FIFO"
}

refresh_log_snapshot() {
  LOG_LINES=()
  if ! docker info >/dev/null 2>&1; then
    return
  fi
  local mode
  local compose_file
  local args=(logs --tail "$TAIL_COUNT")
  mode="$(resolve_mode "logs")"
  compose_file="$(compose_file_for "$mode")"
  if [[ ! -f "$compose_file" ]]; then
    log_append "Compose file not found: $(basename "$compose_file")"
    return
  fi
  if [[ -n "$LOG_SERVICE" && "$LOG_SERVICE" != "all" ]]; then
    args+=("$LOG_SERVICE")
  fi

  run_capture dc "$compose_file" "${args[@]}"
  if [[ "$RUN_STATUS" -ne 0 ]]; then
    log_append "Logs unavailable."
    return
  fi

  local line
  while IFS= read -r line; do
    log_sanitize_line "$line"
    log_append "$_SANITIZED"
  done <<<"$RUN_OUTPUT"
}

drain_log_stream() {
  if [[ -z "${LOG_FD:-}" ]]; then
    return
  fi
  local updated=0
  local line
  while IFS= read -r -t 0.01 line <&$LOG_FD; do
    log_sanitize_line "$line"
    log_append "$_SANITIZED"
    updated=1
  done
  if [[ "$updated" -eq 1 ]]; then
    TUI_NEED_RIGHT=1
  fi
}

tui_refresh_logs_view() {
  if [[ "$FOLLOW_LOGS" == "1" ]]; then
    start_log_stream
  else
    refresh_log_snapshot
  fi
  if [[ "$TUI_ACTIVE" == "1" ]]; then
    TUI_NEED_RIGHT=1
  fi
}

tui_ensure_log_stream() {
  if [[ -n "$LOG_PID" ]] && ! kill -0 "$LOG_PID" >/dev/null 2>&1; then
    stop_log_stream
    TUI_NEED_RIGHT=1
  fi

  if [[ "$FOLLOW_LOGS" != "1" || "$TUI_DOCKER_OK" -ne 1 ]]; then
    return
  fi

  if [[ -z "$LOG_PID" ]]; then
    local now
    printf -v now '%(%s)T' -1
    if [[ -z "$TUI_LAST_LOG_RESTART" || $((now - TUI_LAST_LOG_RESTART)) -ge 1 ]]; then
      start_log_stream
      TUI_LAST_LOG_RESTART="$now"
      TUI_NEED_RIGHT=1
    fi
    return
  fi

  if ! kill -0 "$LOG_PID" >/dev/null 2>&1; then
    local now
    printf -v now '%(%s)T' -1
    if [[ -z "$TUI_LAST_LOG_RESTART" || $((now - TUI_LAST_LOG_RESTART)) -ge 1 ]]; then
      stop_log_stream
      start_log_stream
      TUI_LAST_LOG_RESTART="$now"
      TUI_NEED_RIGHT=1
    fi
  fi
}

tui_render_right_logs() {
  # Update right title bar with spinner
  local spinner=""
  if [[ "$FOLLOW_LOGS" == "1" && -n "$LOG_PID" ]]; then
    local frame_idx=$((_SPINNER_TICK % ${#SPINNER_FRAMES[@]}))
    spinner=" ${SPINNER_FRAMES[$frame_idx]}"
  fi
  TUI_RIGHT_TITLE="☰ Logs: ${LOG_SERVICE:-all}${spinner} │ Tail: ${TAIL_COUNT}"

  # Redraw title bar row with updated right title
  printf '\033[2;%dH' "$((LEFT_W + 2))"
  tui_truncate "$TUI_RIGHT_TITLE" $((TUI_COLS - LEFT_W - 3))
  printf "%s%b %-*s%b%s" \
    "$_BORDER_V" "${TUI_BG_TITLEBAR}${TUI_BOLD}${TUI_FG_TITLE}" \
    "$((TUI_COLS - LEFT_W - 2))" "$_TRUNC" "$CLR_RESET" "$_BORDER_V"

  local count=${#LOG_LINES[@]}
  local start=$((count - RIGHT_CONTENT_HEIGHT))
  if [[ "$start" -lt 0 ]]; then
    start=0
  fi
  local row idx line line_color
  for ((row=0; row<RIGHT_CONTENT_HEIGHT; row++)); do
    idx=$((start + row))
    line=""
    line_color=""
    if [[ "$idx" -lt "$count" ]]; then
      line="${LOG_LINES[$idx]}"
      # Colorize based on content
      if [[ "$line" == *[Ee][Rr][Rr][Oo][Rr]* || "$line" == *ERRO* || "$line" == *panic* ]]; then
        line_color="$TUI_FG_LOG_ERROR"
      elif [[ "$line" == *[Ww][Aa][Rr][Nn]* || "$line" == *WARN* ]]; then
        line_color="$TUI_FG_LOG_WARN"
      else
        line_color="$TUI_FG_LOG_INFO"
      fi
    elif [[ "$count" -eq 0 && "$row" -eq 0 ]]; then
      line="Waiting for logs..."
      line_color="${TUI_DIM}${TUI_ITALIC}"
    fi
    tui_truncate "$line" "$RIGHT_CONTENT_W"
    printf '\033[%d;%dH' "$((RIGHT_CONTENT_ROW + row + 1))" "$((RIGHT_X + 1))"
    if [[ -n "$line_color" ]]; then
      printf "%b%-*s%b" "$line_color" "$RIGHT_CONTENT_W" "$_TRUNC" "$CLR_RESET"
    else
      printf "%-*s" "$RIGHT_CONTENT_W" "$_TRUNC"
    fi
  done
}

prompt_tail_count() {
  local input=""
  read -r -p "Tail lines (current: $TAIL_COUNT): " input
  if [[ -n "$input" ]]; then
    if [[ "$input" =~ ^[0-9]+$ ]]; then
      TAIL_COUNT="$input"
    else
      warn "Invalid number. Keeping $TAIL_COUNT."
    fi
  fi
}

pause() {
  if [[ "$TUI_ACTIVE" == "1" && -t 1 ]]; then
    tui_message "Continue" "Press any key to continue."
  else
    read -r -p "Press Enter to continue..." _
  fi
}

print_header() {
  printf "%b\n" "${CLR_BLUE}Haven Control${CLR_RESET}"
  printf "%b\n\n" "${CLR_DIM}$ROOT_DIR${CLR_RESET}"
}

show_help_screen() {
  local text
  text=$(cat <<'HELP'
Quick help

- Start: prepares missing *.json files, asks import flag, then starts Docker.
- Tor: uses docker-compose.tor.yml and shows the onion address when ready.
- Logs: choose a service and tail size.
- JSON editor: edit arrays inside relays/npubs JSON files.
- Env editor: edit .env values; saving restarts running containers.

JSON files
- relays_import.json: list of relays to import from
- relays_blastr.json: list of relays for blastr
- blacklisted_npubs.json: npubs to block
- whitelisted_npubs.json: npubs allowed (if whitelist mode)

Tip: If a .example.json exists, the start flow will offer to copy it.
HELP
)

  if [[ "$TUI_ACTIVE" == "1" && -t 1 ]]; then
    tui_message "Help" "$text"
  else
    clear
    print_header
    printf "%s\n" "$text"
    pause
  fi
}

tui_update_docker_status() {
  local now
  printf -v now '%(%s)T' -1
  if [[ -z "$TUI_LAST_DOCKER_CHECK" || $((now - TUI_LAST_DOCKER_CHECK)) -ge 5 ]]; then
    local prev="$TUI_DOCKER_OK"
    local next=0
    if docker info >/dev/null 2>&1; then
      next=1
    else
      next=0
    fi
    if [[ "$next" -ne "$prev" ]]; then
      TUI_NEED_LEFT=1
      TUI_NEED_MENU=1
    fi
    TUI_DOCKER_OK="$next"
    TUI_LAST_DOCKER_CHECK="$now"
  fi
}

tui_set_view() {
  TUI_VIEW="$1"
  TUI_SEL=0
  TUI_OFFSET=0
  TUI_NEED_MENU=1
  TUI_NEED_LEFT=1
  TUI_NEED_RIGHT=1
}

tui_menu_icon() {
  case "$1" in
    start_plain)  _ICON="$ICO_DOCKER " ;;
    start_tor)    _ICON="$ICO_TOR " ;;
    stop)         _ICON="$ICO_STOP " ;;
    restart)      _ICON="$ICO_RESTART " ;;
    logs)         _ICON="$ICO_LOGS " ;;
    status)       _ICON="$ICO_STATUS " ;;
    json)         _ICON="$ICO_JSON " ;;
    env)          _ICON="$ICO_ENV " ;;
    onion)        _ICON="$ICO_ONION " ;;
    import)       _ICON="$ICO_IMPORT " ;;
    env_upgrade)  _ICON="$ICO_UPGRADE " ;;
    help)         _ICON="$ICO_HELP " ;;
    quit)         _ICON="$ICO_QUIT " ;;
    back)         _ICON="$ICO_BACK " ;;
    add)          _ICON="$ICO_ADD " ;;
    clear)        _ICON="$ICO_CLEAR " ;;
    edit)         _ICON="$ICO_EDIT " ;;
    remove)       _ICON="$ICO_REMOVE " ;;
    service)      _ICON="$ICO_LOGS " ;;
    tail)         _ICON="# " ;;
    follow)       _ICON="$ICO_RESTART " ;;
    all)          _ICON="$ICO_LOGS " ;;
    key:*)        _ICON="$ICO_ENV " ;;
    item:*)       _ICON="  " ;;
    *)            _ICON="  " ;;
  esac
}

tui_breadcrumb() {
  case "$TUI_VIEW" in
    main)          _CRUMB="Haven" ;;
    logs)          _CRUMB="Haven / Logs" ;;
    logs_service)  _CRUMB="Haven / Logs / Service" ;;
    env_list)      _CRUMB="Haven / .env" ;;
    env_item)      _CRUMB="Haven / .env / $CURRENT_ENV_KEY" ;;
    json_files)    _CRUMB="Haven / JSON" ;;
    json_items)    _CRUMB="Haven / JSON / $(json_label_for "$CURRENT_JSON_FILE")" ;;
    *)             _CRUMB="Haven" ;;
  esac
}

tui_build_menu() {
  MENU_IDS=()
  MENU_LABELS=()
  MENU_TITLE=""
  MENU_SUBTITLE=""

  case "$TUI_VIEW" in
    main)
      local docker_status="offline"
      local docker_icon="○"
      local mode="unknown"
      if [[ "$TUI_DOCKER_OK" -eq 1 ]]; then
        docker_status="running"
        docker_icon="●"
        mode="$(resolve_mode "status")"
      fi
      TUI_LEFT_TITLE="⚡ Haven Dashboard"
      MENU_TITLE="Haven"
      MENU_SUBTITLE="$docker_icon Docker: $docker_status │ Mode: $mode"
      MENU_IDS=(start_plain start_tor stop restart env json env_upgrade onion import help quit)
      MENU_LABELS=("Start (Docker)" "Start (Tor)" "Stop services" "Restart services" ".env Editor" "JSON Editor" "Upgrade .env" "Show Onion Host" "Set Import Flag" "Help" "Quit")
      ;;
    logs)
      TUI_LEFT_TITLE="⚡ Haven ─ Logs"
      MENU_TITLE="Logs Settings"
      MENU_SUBTITLE="Service: ${LOG_SERVICE:-all} │ Tail: ${TAIL_COUNT} │ Follow: $([[ "$FOLLOW_LOGS" == "1" ]] && echo on || echo off)"
      MENU_IDS=(service tail follow back)
      MENU_LABELS=("Select service" "Tail lines" "Toggle follow" "Back")
      ;;
    logs_service)
      TUI_LEFT_TITLE="⚡ Haven ─ Logs ─ Service"
      MENU_TITLE="Log Services"
      MENU_SUBTITLE="Choose which service to stream."
      MENU_IDS=(all)
      MENU_LABELS=("All services")
      local svc
      while IFS= read -r svc; do
        [[ -n "$svc" ]] || continue
        MENU_IDS+=("$svc")
        MENU_LABELS+=("$svc")
      done < <(list_services "$(compose_file_for "$(resolve_mode "logs")")")
      if [[ "${#MENU_IDS[@]}" -eq 1 ]]; then
        MENU_IDS+=(relay tor)
        MENU_LABELS+=("relay" "tor")
      fi
      MENU_IDS+=(back)
      MENU_LABELS+=("Back")
      ;;
    env_list)
      TUI_LEFT_TITLE="⚡ Haven ─ Environment"
      MENU_TITLE=".env Editor"
      MENU_SUBTITLE="Select a variable"
      MENU_IDS=(add)
      MENU_LABELS=("Add variable")
      local key
      while IFS= read -r key; do
        [[ -n "$key" ]] || continue
        local value=""
        value="$(read_env_var "$key" 2>/dev/null || true)"
        MENU_IDS+=("key:$key")
        MENU_LABELS+=("$key = $value")
      done < <(list_env_keys)
      MENU_IDS+=(back)
      MENU_LABELS+=("Back")
      ;;
    env_item)
      TUI_LEFT_TITLE="⚡ Haven ─ .env ─ $CURRENT_ENV_KEY"
      MENU_TITLE=".env: $CURRENT_ENV_KEY"
      MENU_SUBTITLE="Edit or remove this variable."
      MENU_IDS=(edit remove back)
      MENU_LABELS=("Edit value" "Remove variable" "Back")
      ;;
    json_files)
      TUI_LEFT_TITLE="⚡ Haven ─ JSON Editor"
      MENU_TITLE="JSON Editor"
      MENU_SUBTITLE="Select a list"
      local count=${#JSON_FILES[@]}
      local file label
      for ((i=0; i<count; i++)); do
        file="${JSON_FILES[$i]}"
        label="${JSON_LABELS[$i]}"
        MENU_IDS+=("$file")
        MENU_LABELS+=("$label ($file)")
      done
      MENU_IDS+=(back)
      MENU_LABELS+=("Back")
      ;;
    json_items)
      TUI_LEFT_TITLE="⚡ Haven ─ JSON ─ $(json_label_for "$CURRENT_JSON_FILE")"
      MENU_TITLE="JSON: $CURRENT_JSON_FILE"
      MENU_SUBTITLE="Edit list items"
      MENU_IDS=(add clear)
      MENU_LABELS=("Add item" "Clear list")
      local path="$ROOT_DIR/$CURRENT_JSON_FILE"
      local output=""
      if ! output="$(json_list_items "$path" 2>/dev/null)"; then
        MENU_IDS=(back)
        MENU_LABELS=("Invalid JSON (back)")
      else
        local idx=0
        local item
        while IFS= read -r item; do
          MENU_IDS+=("item:$idx")
          if json_item_is_valid "$CURRENT_JSON_FILE" "$item"; then
            MENU_LABELS+=("$item")
          else
            MENU_LABELS+=("$item (invalid)")
          fi
          idx=$((idx + 1))
        done <<<"$output"
        MENU_IDS+=(back)
        MENU_LABELS+=("Back")
      fi
      ;;
  esac
}

tui_render_left_menu() {
  local row="$LEFT_CONTENT_ROW"
  local visible_rows="$LEFT_CONTENT_HEIGHT"

  # Only rebuild menu data when needed (not on simple navigation)
  if [[ "$TUI_NEED_MENU" -eq 1 ]]; then
    tui_build_menu
    TUI_NEED_MENU=0
  fi

  # Breadcrumb row (dim)
  tui_breadcrumb
  tui_truncate "$_CRUMB" "$LEFT_CONTENT_W"
  tui_print_left_styled "$row" "$TUI_DIM" "$_TRUNC"
  row=$((row + 1))
  visible_rows=$((visible_rows - 1))

  # Bold accent title
  if [[ -n "$MENU_TITLE" ]]; then
    tui_truncate "$MENU_TITLE" "$LEFT_CONTENT_W"
    tui_print_left_styled "$row" "${TUI_BOLD}${TUI_FG_ACCENT}" "$_TRUNC"
    row=$((row + 1))
    visible_rows=$((visible_rows - 1))
  fi

  # Dim subtitle
  if [[ -n "$MENU_SUBTITLE" ]]; then
    tui_truncate "$MENU_SUBTITLE" "$LEFT_CONTENT_W"
    tui_print_left_styled "$row" "${TUI_DIM}${TUI_FG_SUBTITLE}" "$_TRUNC"
    row=$((row + 1))
    visible_rows=$((visible_rows - 1))
  fi

  # Thin separator
  tui_print_left_styled "$row" "$TUI_FG_SEPARATOR" "$_HLINE_SEP"
  row=$((row + 1))
  visible_rows=$((visible_rows - 1))

  local count=${#MENU_LABELS[@]}
  if [[ "$count" -le 0 ]]; then
    tui_print_left_styled "$row" "$TUI_DIM" "(empty)"
    return
  fi

  if [[ "$TUI_SEL" -lt 0 ]]; then
    TUI_SEL=0
  fi
  if [[ "$TUI_SEL" -ge "$count" ]]; then
    TUI_SEL=$((count - 1))
  fi

  if [[ "$TUI_SEL" -lt "$TUI_OFFSET" ]]; then
    TUI_OFFSET="$TUI_SEL"
  fi
  if [[ "$TUI_SEL" -ge $((TUI_OFFSET + visible_rows)) ]]; then
    TUI_OFFSET=$((TUI_SEL - visible_rows + 1))
  fi

  local i idx label menu_id icon_len max_label_w
  for ((i=0; i<visible_rows; i++)); do
    idx=$((TUI_OFFSET + i))
    label=""
    menu_id=""
    if [[ "$idx" -lt "$count" ]]; then
      label="${MENU_LABELS[$idx]}"
      menu_id="${MENU_IDS[$idx]}"
    fi

    tui_menu_icon "$menu_id"
    icon_len=${#_ICON}
    max_label_w=$((LEFT_CONTENT_W - icon_len))
    tui_truncate "$label" "$max_label_w"

    printf '\033[%d;%dH' "$((row + i + 1))" "$((LEFT_X + 1))"
    if [[ -z "$label" ]]; then
      printf "%-*s" "$LEFT_CONTENT_W" ""
    elif [[ "$idx" -eq "$TUI_SEL" ]]; then
      printf "%b%-*s%b" \
        "${TUI_BOLD}${TUI_FG_SELECTED}${TUI_BG_SELECTED}" \
        "$LEFT_CONTENT_W" "${ICO_SELECTED}${_TRUNC}" "$CLR_RESET"
    elif [[ "$menu_id" == "back" || "$menu_id" == "quit" ]]; then
      printf "%b%-*s%b" \
        "${TUI_FG_MENU_DIM}" "$LEFT_CONTENT_W" "${_ICON}${_TRUNC}" "$CLR_RESET"
    else
      printf "%b%s%b%-*s%b" \
        "${TUI_FG_ACCENT}" "$_ICON" \
        "${TUI_FG_MENU}" "$((LEFT_CONTENT_W - icon_len))" "$_TRUNC" "$CLR_RESET"
    fi
  done
}

tui_handle_back() {
  case "$TUI_VIEW" in
    main) return 1 ;;
    logs) tui_set_view "main" ;;
    logs_service) tui_set_view "logs" ;;
    env_list) tui_set_view "main" ;;
    env_item) tui_set_view "env_list" ;;
    json_files) tui_set_view "main" ;;
    json_items) tui_set_view "json_files" ;;
    *) tui_set_view "main" ;;
  esac
  return 0
}

tui_run_action() {
  local title="$1"
  shift
  if [[ "$TUI_ACTIVE" == "1" && "$FOLLOW_LOGS" == "1" ]]; then
    stop_log_stream
  fi
  run_capture "$@"
  if [[ "$RUN_STATUS" -ne 0 ]]; then
    local text="Failed (exit $RUN_STATUS)."
    if [[ -n "$RUN_OUTPUT" ]]; then
      text="$text\n\n$RUN_OUTPUT"
    fi
    tui_message "$title" "$text"
  fi
  if [[ "$TUI_ACTIVE" == "1" ]]; then
    TUI_NEED_FRAME=1
    TUI_NEED_MENU=1
    TUI_NEED_LEFT=1
    TUI_NEED_RIGHT=1
    tui_refresh_logs_view
  fi
}

tui_handle_enter() {
  local id="${MENU_IDS[$TUI_SEL]}"

  case "$TUI_VIEW" in
    main)
      case "$id" in
        start_plain)
          tui_require_docker || return
          if tui_confirm "Start services (Docker)?" "y"; then
            tui_run_action "Start" start_services "plain"
          fi
          ;;
        start_tor)
          tui_require_docker || return
          if tui_confirm "Start services (Tor)?" "y"; then
            tui_run_action "Start" start_services "tor"
          fi
          ;;
        stop)
          tui_require_docker || return
          local mode_stop
          mode_stop="$(resolve_mode "stop")"
          if tui_confirm "Stop services ($mode_stop)?" "y"; then
            tui_run_action "Stop" stop_services "$mode_stop"
          fi
          ;;
        restart)
          tui_require_docker || return
          local mode_restart
          mode_restart="$(resolve_mode "restart")"
          if tui_confirm "Restart services ($mode_restart)?" "y"; then
            tui_run_action "Restart" restart_services "$mode_restart"
          fi
          ;;
        logs)
          tui_set_view "logs"
          ;;
        status)
          tui_require_docker || return
          local mode_status
          local compose_file
          mode_status="$(resolve_mode "status")"
          compose_file="$(compose_file_for "$mode_status")"
          run_capture dc "$compose_file" ps
          tui_message "Status" "$RUN_OUTPUT"
          ;;
        env)
          if ! ensure_env_file; then
            tui_message ".env" ".env missing."
            return
          fi
          tui_set_view "env_list"
          ;;
        json)
          if ! detect_json_tool; then
            tui_message "JSON Editor" "jq or python3 is required for JSON editing."
            return
          fi
          tui_set_view "json_files"
          ;;
        onion)
          local onion_text=""
          local onion_host_file="$ROOT_DIR/tor/data/haven/hostname"
          local onion_torrc="$ROOT_DIR/tor/torrc"
          if [[ -f "$onion_host_file" ]]; then
            onion_text="$(cat "$onion_host_file")"
          else
            onion_text="Hostname not found. Tor may still be initializing."
          fi
          if [[ -f "$onion_torrc" ]]; then
            onion_text="$onion_text

torrc:
$(cat "$onion_torrc")"
          fi
          tui_message "Onion Host" "$onion_text"
          ;;
        import)
          prompt_import_flag
          local value=""
          value="$(read_env_var HAVEN_IMPORT_FLAG 2>/dev/null || true)"
          tui_message "Import Flag" "HAVEN_IMPORT_FLAG=$value"
          ;;
        env_upgrade)
          if [[ ! -f "$ROOT_DIR/.env.example" ]]; then
            tui_message "Upgrade .env" ".env.example not found."
            return
          fi
          if [[ ! -f "$ROOT_DIR/.env" ]]; then
            if tui_confirm "No .env found. Create from .env.example?" "y"; then
              cp "$ROOT_DIR/.env.example" "$ROOT_DIR/.env"
              tui_message "Upgrade .env" ".env created from .env.example.\n\nPlease edit your .env and then\nrestart services."
            fi
            return
          fi
          local upgrade_missing=""
          upgrade_missing="$(list_missing_env_vars)"
          local upgrade_count=0
          if [[ -n "$upgrade_missing" ]]; then
            upgrade_count="$(printf "%s\n" "$upgrade_missing" | wc -l)"
            upgrade_count="${upgrade_count// /}"
          fi
          if [[ "$upgrade_count" -eq 0 ]]; then
            tui_message "Upgrade .env" "No missing variables found.\nYour .env is up to date."
            return
          fi
          local upgrade_preview=""
          upgrade_preview="$(printf "%s\n" "$upgrade_missing" | head -n 10)"
          if [[ "$upgrade_count" -gt 10 ]]; then
            upgrade_preview="$upgrade_preview\n... and $((upgrade_count - 10)) more"
          fi
          tui_message "Missing Variables" "$upgrade_count variable(s) found:\n\n$upgrade_preview"
          if tui_confirm "Add to .env?" "y"; then
            upgrade_env_file
            tui_message "Upgrade .env" "$upgrade_count variable(s) added.\n\nPlease review and edit your\n.env file, then restart\nservices."
          fi
          ;;
        help)
          show_help_screen
          ;;
        quit)
          return 1
          ;;
      esac
      ;;
    logs)
      case "$id" in
        service)
          tui_set_view "logs_service"
          ;;
        tail)
          local new_tail
          new_tail="$(tui_prompt "Tail lines: " "$TAIL_COUNT")"
          if [[ "$new_tail" =~ ^[0-9]+$ ]]; then
            TAIL_COUNT="$new_tail"
            if [[ "$FOLLOW_LOGS" == "1" ]]; then
              start_log_stream
            else
              refresh_log_snapshot
            fi
            TUI_NEED_RIGHT=1
          else
            tui_message "Logs" "Tail must be a number."
          fi
          ;;
        follow)
          if [[ "$FOLLOW_LOGS" == "1" ]]; then
            FOLLOW_LOGS=0
            stop_log_stream
            refresh_log_snapshot
          else
            FOLLOW_LOGS=1
            start_log_stream
          fi
          TUI_NEED_RIGHT=1
          ;;
        back)
          tui_set_view "main"
          ;;
      esac
      ;;
    logs_service)
      if [[ "$id" == "back" ]]; then
        tui_set_view "logs"
      else
        LOG_SERVICE="$id"
        if [[ "$FOLLOW_LOGS" == "1" ]]; then
          start_log_stream
        else
          refresh_log_snapshot
        fi
        TUI_NEED_RIGHT=1
        tui_set_view "logs"
      fi
      ;;
    env_list)
      case "$id" in
        add)
          local new_key
          local new_value
          new_key="$(tui_prompt "New key: " "")"
          if [[ -z "$new_key" ]]; then
            tui_message ".env" "Key is empty."
            return
          fi
          if [[ ! "$new_key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
            tui_message ".env" "Invalid key format."
            return
          fi
          new_value="$(tui_prompt "New value: " "")"
          if ! validate_env_value "$new_key" "$new_value"; then
            tui_message ".env" "$VALIDATION_ERROR"
            return
          fi
          set_env_var "$new_key" "$VALIDATION_VALUE"
          restart_after_env_change
          ;;
        back)
          tui_set_view "main"
          ;;
        *)
          if [[ "$id" == key:* ]]; then
            CURRENT_ENV_KEY="${id#key:}"
            tui_set_view "env_item"
          fi
          ;;
      esac
      ;;
    env_item)
      case "$id" in
        edit)
          local current=""
          local new_value=""
          current="$(read_env_var "$CURRENT_ENV_KEY" 2>/dev/null || true)"
          new_value="$(tui_prompt "New value (blank to keep): " "$current")"
          if [[ -z "$new_value" ]]; then
            return
          fi
          if ! validate_env_value "$CURRENT_ENV_KEY" "$new_value"; then
            tui_message ".env" "$VALIDATION_ERROR"
            return
          fi
          set_env_var "$CURRENT_ENV_KEY" "$VALIDATION_VALUE"
          restart_after_env_change
          ;;
        remove)
          if tui_confirm "Remove $CURRENT_ENV_KEY?" "n"; then
            remove_env_var "$CURRENT_ENV_KEY"
            restart_after_env_change
          fi
          ;;
        back)
          tui_set_view "env_list"
          ;;
      esac
      ;;
    json_files)
      if [[ "$id" == "back" ]]; then
        tui_set_view "main"
      else
        CURRENT_JSON_FILE="$id"
        if ! ensure_json_array_file "$CURRENT_JSON_FILE"; then
          tui_message "JSON Editor" "File missing or invalid."
          return
        fi
        tui_set_view "json_items"
      fi
      ;;
    json_items)
      case "$id" in
        add)
          local new_item
          new_item="$(tui_prompt "Add item: " "")"
          if [[ -z "$new_item" ]]; then
            tui_message "JSON Editor" "Item is empty."
            return
          fi
          if ! validate_json_item "$CURRENT_JSON_FILE" "$new_item"; then
            tui_message "JSON Editor" "$VALIDATION_ERROR"
            return
          fi
          local item_to_add="$VALIDATION_VALUE"
          local path="$ROOT_DIR/$CURRENT_JSON_FILE"
          run_capture json_list_items "$path"
          local duplicate=0
          local existing
          while IFS= read -r existing; do
            if [[ "$existing" == "$item_to_add" ]]; then
              duplicate=1
              break
            fi
          done <<<"$RUN_OUTPUT"
          if [[ "$duplicate" == "1" ]]; then
            tui_message "JSON Editor" "Item already exists."
            return
          fi
          json_add_item "$path" "$item_to_add"
          ;;
        clear)
          if tui_confirm "Clear entire list?" "n"; then
            json_clear "$ROOT_DIR/$CURRENT_JSON_FILE"
          fi
          ;;
        back)
          tui_set_view "json_files"
          ;;
        item:*)
          local index="${id#item:}"
          local path="$ROOT_DIR/$CURRENT_JSON_FILE"
          local output=""
          output="$(json_list_items "$path" 2>/dev/null || true)"
          local current_item=""
          current_item="$(printf "%s" "$output" | sed -n "$((index + 1))p")"
          if [[ -n "$current_item" ]]; then
            if tui_confirm "Remove item?\n\n$current_item" "n"; then
              json_remove_index "$path" "$index"
            fi
          fi
          ;;
      esac
      ;;
  esac
  TUI_NEED_MENU=1
  TUI_NEED_LEFT=1
  TUI_NEED_RIGHT=1
  return 0
}

tui_handle_key() {
  local key="$1"
  local count=${#MENU_IDS[@]}

  case "$key" in
    up)
      if [[ "$TUI_SEL" -gt 0 ]]; then
        TUI_SEL=$((TUI_SEL - 1))
        TUI_NEED_LEFT=1
      fi
      ;;
    down)
      if [[ "$TUI_SEL" -lt $((count - 1)) ]]; then
        TUI_SEL=$((TUI_SEL + 1))
        TUI_NEED_LEFT=1
      fi
      ;;
    enter)
      tui_handle_enter || return 1
      ;;
    left|esc)
      tui_handle_back || return 1
      ;;
    quit)
      if [[ "$TUI_VIEW" == "main" ]]; then
        return 1
      fi
      tui_handle_back
      ;;
  esac
  return 0
}

tui_loop() {
  local start_view="$1"
  local running=1

  tui_init
  trap 'TUI_NEED_RESIZE=1' SIGWINCH

  if [[ -n "$start_view" ]]; then
    TUI_VIEW="$start_view"
  else
    TUI_VIEW="main"
  fi
  TUI_SEL=0
  TUI_OFFSET=0
  TUI_NEED_FRAME=1
  TUI_NEED_LEFT=1
  TUI_NEED_RIGHT=1

  if [[ -z "$LOG_SERVICE" ]]; then
    LOG_SERVICE="relay"
  fi
  TUI_RIGHT_TITLE="☰ Logs: ${LOG_SERVICE:-all}"
  _SPINNER_TICK=0

  tui_update_docker_status
  if [[ "$FOLLOW_LOGS" == "1" ]]; then
    start_log_stream
  else
    refresh_log_snapshot
  fi

  while [[ "$running" -eq 1 ]]; do
    if [[ "$TUI_NEED_RESIZE" -eq 1 ]]; then
      TUI_NEED_RESIZE=0
      tui_update_layout
      TUI_NEED_FRAME=1
      TUI_NEED_MENU=1
      TUI_NEED_LEFT=1
      TUI_NEED_RIGHT=1
    fi

    _SPINNER_TICK=$((_SPINNER_TICK + 1))
    if (( _SPINNER_TICK % 4 == 0 && FOLLOW_LOGS == 1 )); then
      TUI_NEED_RIGHT=1
    fi

    tui_update_docker_status
    tui_ensure_log_stream
    drain_log_stream

    if [[ "$TUI_NEED_FRAME" -eq 1 ]]; then
      tui_draw_frame 1
      TUI_NEED_FRAME=0
      TUI_NEED_LEFT=1
      TUI_NEED_RIGHT=1
    fi

    if [[ "$TUI_NEED_RIGHT" -eq 1 ]]; then
      tui_render_right_logs
      TUI_NEED_RIGHT=0
    fi

    if [[ "$TUI_NEED_LEFT" -eq 1 ]]; then
      tui_render_left_menu
      TUI_NEED_LEFT=0
    fi

    tui_read_key || continue
    if ! tui_handle_key "$_KEY"; then
      running=0
    fi
  done
}

restart_after_env_change() {
  if ! docker info >/dev/null 2>&1; then
    warn "Docker not running; restart skipped."
    return
  fi

  local mode=""
  if docker ps --format '{{.Names}}' | grep -qx 'haven-tor'; then
    mode="tor"
  elif docker ps --format '{{.Names}}' | grep -qx 'haven-relay'; then
    mode="plain"
  else
    warn "No running containers to restart."
    return
  fi

  info "Restarting services ($mode) to apply .env changes..."
  local prev_skip="$SKIP_IMPORT_PROMPT"
  local prev_import="$IMPORT_MODE"
  SKIP_IMPORT_PROMPT=1
  IMPORT_MODE="auto"
  restart_services "$mode"
  IMPORT_MODE="$prev_import"
  SKIP_IMPORT_PROMPT="$prev_skip"
}

menu_env_editor() {
  if [[ "$TUI_ACTIVE" == "1" ]]; then
    if ! ensure_env_file; then
      tui_message ".env" ".env missing."
      return
    fi
    tui_set_view "env_list"
    return
  fi
  if [[ ! -t 0 ]]; then
    die "Env editor requires a TTY."
  fi
  if ! ensure_env_file; then
    die ".env missing."
  fi
  tui_loop "env_list"
}

menu_logs() {
  if [[ "$TUI_ACTIVE" == "1" ]]; then
    tui_set_view "logs"
    return
  fi
  if [[ -t 0 ]]; then
    tui_loop "logs"
  else
    LOG_SERVICE="all"
    local mode
    local compose_file
    mode="$(resolve_mode "logs")"
    compose_file="$(compose_file_for "$mode")"
    require_compose_file "$compose_file"
    stream_logs "$mode" "$compose_file" "$LOG_SERVICE"
  fi
}

menu_json_editor() {
  if [[ "$TUI_ACTIVE" == "1" ]]; then
    if ! detect_json_tool; then
      tui_message "JSON Editor" "jq or python3 is required for JSON editing."
      return
    fi
    tui_set_view "json_files"
    return
  fi
  if [[ ! -t 0 ]]; then
    die "JSON editor requires a TTY."
  fi
  if ! detect_json_tool; then
    die "jq or python3 is required for JSON editing."
  fi
  tui_loop "json_files"
}

tui() {
  if [[ ! -t 0 ]]; then
    die "TUI requires a TTY. Use CLI commands instead."
  fi
  tui_loop "main"
}

parse_args() {
  if [[ $# -eq 0 ]]; then
    COMMAND="tui"
    return
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      start|stop|restart|logs|status|tui|help|import|onion|json|env|env-upgrade)
        COMMAND="$1"
        shift
        ;;
      -t|--tor)
        MODE="tor"
        shift
        ;;
      --plain)
        MODE="plain"
        shift
        ;;
      --import)
        IMPORT_MODE="true"
        shift
        ;;
      --no-import)
        IMPORT_MODE="false"
        shift
        ;;
      --prompt-import)
        IMPORT_MODE="prompt"
        shift
        ;;
      --tail)
        [[ $# -lt 2 ]] && die "--tail requires a number"
        TAIL_COUNT="$2"
        shift 2
        ;;
      -s|--service)
        [[ $# -lt 2 ]] && die "--service requires a name"
        LOG_SERVICE="$2"
        shift 2
        ;;
      --all)
        LOG_SERVICE="all"
        shift
        ;;
      --no-follow)
        FOLLOW_LOGS=0
        shift
        ;;
      --no-build)
        BUILD_IMAGES=0
        shift
        ;;
      --build)
        BUILD_IMAGES=1
        shift
        ;;
      -h|--help)
        COMMAND="help"
        shift
        ;;
      *)
        die "Unknown argument: $1"
        ;;
    esac
  done
}

main() {
  cd "$ROOT_DIR"
  detect_compose
  parse_args "$@"

  case "$COMMAND" in
    tui)
      tui
      ;;
    start)
      ensure_docker
      start_services "$(resolve_mode "start")"
      ;;
    stop)
      ensure_docker
      stop_services "$(resolve_mode "stop")"
      ;;
    restart)
      ensure_docker
      restart_services "$(resolve_mode "restart")"
      ;;
    logs)
      if [[ -z "$LOG_SERVICE" ]]; then
        if [[ -t 0 ]]; then
          menu_logs
        else
          LOG_SERVICE="all"
        fi
      fi

      if [[ -n "$LOG_SERVICE" ]]; then
        ensure_docker
        local mode
        local compose_file
        mode="$(resolve_mode "logs")"
        compose_file="$(compose_file_for "$mode")"
        require_compose_file "$compose_file"
        stream_logs "$mode" "$compose_file" "$LOG_SERVICE"
      fi
      ;;
    status)
      ensure_docker
      show_status "$(resolve_mode "status")"
      ;;
    onion)
      show_onion_host
      ;;
    import)
      prompt_import_flag
      ;;
    env)
      menu_env_editor
      ;;
    env-upgrade)
      if [[ ! -f "$ROOT_DIR/.env.example" ]]; then
        die ".env.example not found."
      fi
      if [[ ! -f "$ROOT_DIR/.env" ]]; then
        cp "$ROOT_DIR/.env.example" "$ROOT_DIR/.env"
        success ".env created from .env.example."
        info "Please edit your .env and then restart services."
        exit 0
      fi
      local missing_vars=""
      missing_vars="$(list_missing_env_vars)"
      local missing_count=0
      if [[ -n "$missing_vars" ]]; then
        missing_count="$(printf "%s\n" "$missing_vars" | wc -l)"
        missing_count="${missing_count// /}"
      fi
      if [[ "$missing_count" -eq 0 ]]; then
        success "No missing variables. Your .env is up to date."
        exit 0
      fi
      info "$missing_count new variable(s) found:"
      printf "%s\n" "$missing_vars"
      upgrade_env_file
      success "$missing_count variable(s) added to .env."
      info "Please review and edit your .env file, then restart services."
      ;;
    json)
      menu_json_editor
      ;;
    help|"")
      print_usage
      ;;
    *)
      die "Unknown command: $COMMAND"
      ;;
  esac
}

main "$@"
